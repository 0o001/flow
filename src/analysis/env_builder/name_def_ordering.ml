(*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *)

open Reason
open Loc_collections
open Name_def
open Dependency_sigs
module EnvMap = Env_api.EnvMap
module EnvSet = Env_api.EnvSet

module Tarjan =
  Tarjan.Make
    (struct
      include Env_api.EnvKey

      let to_string (_, l) = ALoc.debug_to_string l
    end)
    (EnvMap)
    (EnvSet)

type 'k blame = {
  payload: 'k;
  reason: ALoc.t virtual_reason;
  annot_locs: ALoc.t list;
  recursion: ALoc.t Nel.t;
}

type element =
  | Normal of Env_api.EnvKey.t
  | Resolvable of Env_api.EnvKey.t
  | Illegal of Env_api.EnvKey.t blame

type result =
  | Singleton of element
  | ResolvableSCC of element Nel.t
  | IllegalSCC of element blame Nel.t

let string_of_element graph =
  let print_elt k =
    match EnvMap.find_opt k graph with
    | None -> "MISSING DEFINITION"
    | Some (def, _, _, _) -> Print.string_of_source def
  in
  function
  | Normal (k, l) ->
    Utils_js.spf
      "[%s (%s): %s]"
      (ALoc.debug_to_string l)
      (Env_api.show_def_loc_type k)
      (print_elt (k, l))
  | Resolvable (k, l) ->
    Utils_js.spf
      "[recursive %s (%s): %s]"
      (ALoc.debug_to_string l)
      (Env_api.show_def_loc_type k)
      (print_elt (k, l))
  | Illegal { payload = (k, l); _ } ->
    Utils_js.spf
      "[illegal %s (%s): %s]"
      (ALoc.debug_to_string l)
      (Env_api.show_def_loc_type k)
      (print_elt (k, l))

let string_of_component graph = function
  | Singleton elt -> string_of_element graph elt
  | ResolvableSCC elts ->
    Utils_js.spf
      "{(recursive cycle)\n%s\n}"
      (Nel.to_list elts |> Base.List.map ~f:(string_of_element graph) |> String.concat ",\n")
  | IllegalSCC elts ->
    Utils_js.spf
      "{(illegal cycle)\n%s\n}"
      (Nel.to_list elts
      |> Base.List.map ~f:(fun { payload = elt; _ } -> string_of_element graph elt)
      |> String.concat ",\n"
      )

module type S = sig
  type cx

  val build_ordering :
    cx ->
    Env_api.env_info ->
    (Name_def.def * 'a * ALoc.t list * ALoc.t Reason.virtual_reason) EnvMap.t ->
    result Base.List.t
end

module Make (Context : C) (FlowAPIUtils : F with type cx = Context.t) : S with type cx = Context.t =
struct
  type cx = Context.t

  module FindDependencies : sig
    val depends :
      Context.t ->
      EnvMap.key option EnvMap.t ->
      Env_api.env_info ->
      ALoc.t ->
      Name_def.def ->
      ALoc.t Nel.t EnvMap.t

    val recursively_resolvable : Name_def.def -> bool
  end = struct
    (* This analysis consumes variable defs and returns a map representing the variables that need to be
       resolved before we can resolve this def.

       Consider for example the program

         1: var x = 42;
         2: type T = typeof x;

       And let's specifically look at the def `TypeAlias(type T = typeof x)`, which will be one of the
       defs generated by the analysis in `name_def.ml`. Given this def, the question that this module
       answers is what variable definitions need to be resolved before the `TypeAlias` def itself can be resolved.

       We can see that the type alias depends on reading `x`, so in order to actually resolve the type alias, we
       first need to know the type of `x`. In order to do that, we need to have resolved the writes that (according
       to the name_resolver) reach this reference to `x`. That's what this analysis tells us--it will traverse the
       TypeAlias def, find the read of `x`, and add the writes to `x` that reach that read to the set of defs that need to
       be resolved before the type alias can be resolved. We'll ultimately use this to figure out the correct ordering
       of nodes.

       The actual output of this analysis is a map, whose keys are the locations of variables whose defs need to be resolved
       before this def can be. The values of this map are the locations within the def itself that led us to those variable definitions--
       in this case, the result will be [def of `x`] => [dereference of `x`]. This information is included for good error messages eventually,
       but the more important bit for the correctness of the analysis is the keys of the map--it may be easier to think of the map
       as a set and ignore the values.
    *)

    (* Helper class for the dependency analysis--traverse the AST nodes
       in a def to determine which variables appear *)
    class use_visitor cx this_super_dep_loc_map ({ Env_api.env_values; env_entries; _ } as env) init
      =
      object (this)
        inherit [ALoc.t Nel.t EnvMap.t, ALoc.t] Flow_ast_visitor.visitor ~init as super

        method add ~why t =
          if Env_api.has_assigning_write t env_entries then
            this#update_acc (fun uses ->
                EnvMap.update
                  t
                  (function
                    | None -> Some (Nel.one why)
                    | Some locs ->
                      Some
                        ( if Nel.mem ~equal:ALoc.equal why locs then
                          locs
                        else
                          Nel.cons why locs
                        ))
                  uses
            )

        method find_writes ~for_type ?(allow_missing = false) loc =
          let write_locs =
            try Env_api.write_locs_of_read_loc env_values loc with
            | Not_found ->
              if not allow_missing then
                FlowAPIUtils.add_output cx Error_message.(EInternal (loc, MissingEnvRead loc));
              []
          in
          let writes =
            write_locs
            |> Base.List.concat_map ~f:(Env_api.writes_of_write_loc ~for_type)
            |> Base.List.filter_map ~f:(fun kind_and_loc ->
                   EnvMap.find_opt kind_and_loc this_super_dep_loc_map
                   |> Base.Option.value ~default:(Some kind_and_loc)
               )
          in
          let refinements =
            Base.List.concat_map ~f:(Env_api.refinements_of_write_loc env) write_locs
          in
          let rec writes_of_refinement refi =
            let open Env_api.Refi in
            match refi with
            | InstanceOfR ((_loc, _) as exp)
            | LatentR { func = (_loc, _) as exp; _ } ->
              ignore (this#expression exp)
            | SentinelR (_prop, loc) -> this#add ~why:loc (Env_api.ExpressionLoc, loc)
            | AndR (l, r)
            | OrR (l, r) ->
              writes_of_refinement l;
              writes_of_refinement r
            | NotR r -> writes_of_refinement r
            | TruthyR
            | NullR
            | UndefinedR
            | MaybeR
            | IsArrayR
            | BoolR _
            | FunctionR
            | NumberR _
            | ObjectR
            | StringR _
            | SymbolR _
            | SingletonBoolR _
            | SingletonStrR _
            | SingletonNumR _
            | PropExistsR _ ->
              ()
          in
          Base.List.iter ~f:writes_of_refinement refinements;
          writes

        (* In order to resolve a def containing a variable read, the writes that the
           Name_resolver determines reach the variable must be resolved *)
        method! identifier ((loc, _) as id) =
          let writes = this#find_writes ~for_type:false loc in
          Base.List.iter ~f:(this#add ~why:loc) writes;
          id

        method! type_identifier_reference ((loc, _) as id) =
          let writes = this#find_writes ~for_type:true loc in
          Base.List.iter ~f:(this#add ~why:loc) writes;
          id

        (* In order to resolve a def containing a variable read, the writes that the
           Name_resolver determines reach the variable must be resolved *)
        method! yield loc yield =
          let writes = this#find_writes ~for_type:false loc in
          Base.List.iter ~f:(this#add ~why:loc) writes;
          super#yield loc yield

        (* In order to resolve a def containing a variable write, the
           write itself should first be resolved *)
        method! pattern_identifier ?kind:_ ((loc, _) as id) =
          (* Ignore cases that don't have bindings in the environment, like `var x;`
             and illegal or unreachable writes. *)
          this#add ~why:loc (Env_api.OrdinaryNameLoc, loc);
          id

        method! binding_type_identifier ((loc, _) as id) =
          this#add ~why:loc (Env_api.OrdinaryNameLoc, loc);
          id

        method! this_expression loc this_ =
          let writes = this#find_writes ~for_type:false loc in
          Base.List.iter ~f:(this#add ~why:loc) writes;
          this_

        method! super_expression loc this_ =
          let writes = this#find_writes ~for_type:false loc in
          Base.List.iter ~f:(this#add ~why:loc) writes;
          this_

        (* Skip names in function parameter types (e.g. declared functions) *)
        method! function_param_type (fpt : ('loc, 'loc) Ast.Type.Function.Param.t) =
          let open Ast.Type.Function.Param in
          let (_, { annot; _ }) = fpt in
          let _annot' = this#type_ annot in
          fpt

        method! member_property_identifier (id : (ALoc.t, ALoc.t) Ast.Identifier.t) = id

        method! typeof_member_identifier ident = ident

        method! member_type_identifier (id : (ALoc.t, ALoc.t) Ast.Identifier.t) = id

        method! pattern_object_property_identifier_key ?kind:_ id = id

        method! enum_member_identifier id = id

        method! object_key_identifier (id : (ALoc.t, ALoc.t) Ast.Identifier.t) = id

        method! remote_identifier ident = ident

        method! export_named_declaration_specifier
            (spec : 'loc Ast.Statement.ExportNamedDeclaration.ExportSpecifier.t) =
          let open Ast.Statement.ExportNamedDeclaration.ExportSpecifier in
          (* Ignore renamed export *)
          let (_, { local; exported = _ }) = spec in
          let _local : (_, _) Ast.Identifier.t = this#identifier local in
          spec

        (* For classes/functions that are known to be fully annotated, we skip property bodies *)
        method function_def ~fully_annotated (expr : ('loc, 'loc) Ast.Function.t) =
          let { Ast.Function.params; body; predicate; return; tparams; _ } = expr in
          let open Flow_ast_mapper in
          let _ = this#function_params params in
          let _ =
            if fully_annotated then
              (this#type_annotation_hint return, body)
            else
              (return, this#function_body_any body)
          in
          let _ = map_opt this#predicate predicate in
          let _ = map_opt this#type_params tparams in
          ()

        method! function_ loc expr =
          let { Ast.Function.id; _ } = expr in
          (match id with
          | Some _ -> ()
          | None -> this#add ~why:loc (Env_api.OrdinaryNameLoc, loc));
          super#function_ loc expr

        method class_body_annotated (cls_body : ('loc, 'loc) Ast.Class.Body.t) =
          let open Ast.Class.Body in
          let (_, { body; comments = _ }) = cls_body in
          Base.List.iter ~f:this#class_element_annotated body;
          cls_body

        method class_element_annotated (elem : ('loc, 'loc) Ast.Class.Body.element) =
          let open Ast.Class.Body in
          match elem with
          | Method (_, meth) -> this#class_method_annotated meth
          | Property (_, prop) -> this#class_property_annotated prop
          | PrivateField (_, field) -> this#class_private_field_annotated field

        method class_method_annotated (meth : ('loc, 'loc) Ast.Class.Method.t') =
          let open Ast.Class.Method in
          let { kind = _; key; value = (_, value); static = _; decorators; comments = _ } = meth in
          let _ = Base.List.map ~f:this#class_decorator decorators in
          let _ = this#object_key key in
          let _ = this#function_def ~fully_annotated:true value in
          ()

        method private class_property_value_annotated value =
          let open Ast.Class.Property in
          match value with
          | Initialized
              ((_, Ast.Expression.ArrowFunction function_) | (_, Ast.Expression.Function function_))
            ->
            this#function_def ~fully_annotated:true function_;
            value
          | Initialized _ -> value
          | Declared -> value
          | Uninitialized -> value

        method class_property_annotated (prop : ('loc, 'loc) Ast.Class.Property.t') =
          let open Ast.Class.Property in
          let { key; value; annot; static = _; variance = _; comments = _ } = prop in
          let _ = this#object_key key in
          let _ = this#type_annotation_hint annot in
          let _ = this#class_property_value_annotated value in
          ()

        method class_private_field_annotated (prop : ('loc, 'loc) Ast.Class.PrivateField.t') =
          let open Ast.Class.PrivateField in
          let { key; value; annot; static = _; variance = _; comments = _ } = prop in
          let _ = this#private_name key in
          let _ = this#type_annotation_hint annot in
          let _ = this#class_property_value_annotated value in
          ()

        (* In order to resolve a def containing a read, the writes that the
           Name_resolver determines reach the variable must be resolved *)
        method! expression ((loc, _) as expr) =
          (* An expression might read an refined value. e.g. if (foo.bar) foo.bar.
             Therefore, we need to record these writes. *)
          let writes = this#find_writes ~for_type:false ~allow_missing:true loc in
          Base.List.iter ~f:(this#add ~why:loc) writes;
          this#add ~why:loc (Env_api.OrdinaryNameLoc, loc);
          this#add ~why:loc (Env_api.ExpressionLoc, loc);
          this#add ~why:loc (Env_api.ArrayProviderLoc, loc);
          super#expression expr

        method visit_expression_for_expression_writes expr = ignore @@ super#expression expr
      end

    (* For all the possible defs, explore the def's structure with the class above
       to find what variables have to be resolved before this def itself can be resolved *)
    let depends cx this_super_dep_loc_map ({ Env_api.providers; env_entries; _ } as env) id_loc =
      let depends_of_node mk_visit state =
        let visitor = new use_visitor cx this_super_dep_loc_map env EnvMap.empty in
        visitor#set_acc state;
        let node_visit () = mk_visit visitor in
        visitor#eval node_visit ()
      in
      let depends_of_tparams_map tparams_map =
        depends_of_node (fun visitor ->
            ALocMap.iter
              (fun loc _ -> visitor#add ~why:loc (Env_api.OrdinaryNameLoc, loc))
              tparams_map
        )
      in
      (* depends_of_annotation and of_expression take the `state` parameter from
         `depends_of_node` above as an additional currried parameter. *)
      let depends_of_annotation tparams_map anno state =
        state
        |> depends_of_tparams_map tparams_map
        |> depends_of_node (fun visitor -> ignore @@ visitor#type_annotation anno)
      in
      let depends_of_expression ?(for_expression_writes = false) expr =
        depends_of_node (fun visitor ->
            if for_expression_writes then
              visitor#visit_expression_for_expression_writes expr
            else
              ignore @@ visitor#expression expr
        )
      in
      let depends_of_hint_node state = function
        | AnnotationHint (tparams_map, anno) -> depends_of_annotation tparams_map anno state
        | ValueHint e -> depends_of_expression e state
        | ProvidersHint providers ->
          Nel.fold_left
            (fun state loc ->
              depends_of_node
                (fun visitor -> visitor#add ~why:loc (Env_api.OrdinaryNameLoc, loc))
                state)
            state
            providers
      in
      let rec depends_of_hint state = function
        | Hint_api.Hint_None -> state
        | Hint_api.Hint_Placeholder -> state
        | Hint_api.Hint_t hint_node -> depends_of_hint_node state hint_node
        | Hint_api.Hint_Decomp (ops, hint_node) ->
          Nel.fold_left
            (fun acc (_id, op) ->
              match op with
              | Hint_api.Decomp_SentinelRefinement checks ->
                SMap.fold
                  (fun _ check acc ->
                    match check with
                    | Hint_api.Member r ->
                      let loc = aloc_of_reason r in
                      depends_of_node
                        (fun visitor -> visitor#add ~why:loc (Env_api.ExpressionLoc, loc))
                        acc
                    | _ -> acc)
                  checks
                  acc
              | Hint_api.Instantiate_Callee { Hint_api.return_hint; arg_list; arg_index; _ } ->
                let rec loop acc i = function
                  | [] -> acc
                  | _ when i >= arg_index -> acc
                  | arg :: rest ->
                    let acc =
                      depends_of_node
                        (fun visitor -> ignore @@ visitor#expression_or_spread arg)
                        acc
                    in
                    loop acc (i + 1) rest
                in
                let (_, { Ast.Expression.ArgList.arguments; comments = _ }) = Lazy.force arg_list in
                loop (depends_of_hint acc return_hint) 0 arguments
              | _ -> acc)
            (depends_of_hint_node state hint_node)
            ops
      in

      let depends_of_fun fully_annotated tparams_map hint ~statics function_ state =
        let state = depends_of_hint state hint in
        let state =
          depends_of_node
            (fun visitor -> visitor#function_def ~fully_annotated function_)
            (depends_of_tparams_map tparams_map state)
        in
        depends_of_node
          (fun visitor -> SMap.iter (fun _ expr -> ignore @@ visitor#expression expr) statics)
          state
      in
      let depends_of_class
          { Ast.Class.id = _; body; tparams; extends; implements; class_decorators; comments = _ } =
        depends_of_node
          (fun visitor ->
            let open Flow_ast_mapper in
            let _ = visitor#class_body_annotated body in
            let _ = map_opt (map_loc visitor#class_extends) extends in
            let _ = map_opt visitor#class_implements implements in
            let _ = map_list visitor#class_decorator class_decorators in
            let _ = map_opt visitor#type_params tparams in
            ())
          EnvMap.empty
      in
      let depends_of_declared_class
          {
            Ast.Statement.DeclareClass.id = _;
            tparams;
            body;
            extends;
            mixins;
            implements;
            comments = _;
          } =
        depends_of_node
          (fun visitor ->
            let open Flow_ast_mapper in
            let _ = map_opt visitor#type_params tparams in
            let _ = map_loc visitor#object_type body in
            let _ = map_opt (map_loc visitor#generic_type) extends in
            let _ = map_list (map_loc visitor#generic_type) mixins in
            let _ = map_opt visitor#class_implements implements in
            ())
          EnvMap.empty
      in
      let depends_of_declared_module
          { Ast.Statement.DeclareModule.id = _; body; kind = _; comments = _ } =
        depends_of_node
          (fun visitor ->
            let open Flow_ast_mapper in
            let _ = map_loc visitor#block body in
            ())
          EnvMap.empty
      in
      let depends_of_alias { Ast.Statement.TypeAlias.tparams; right; _ } =
        depends_of_node
          (fun visitor ->
            let open Flow_ast_mapper in
            let _ = map_opt visitor#type_params tparams in
            let _ = visitor#type_ right in
            ())
          EnvMap.empty
      in
      let depends_of_opaque { Ast.Statement.OpaqueType.tparams; impltype; supertype; _ } =
        depends_of_node
          (fun visitor ->
            let open Flow_ast_mapper in
            let _ = map_opt visitor#type_params tparams in
            let _ = map_opt visitor#type_ impltype in
            let _ = map_opt visitor#type_ supertype in
            ())
          EnvMap.empty
      in
      let depends_of_tparam tparams_map (_, { Ast.Type.TypeParam.bound; variance; default; _ }) =
        depends_of_node
          (fun visitor ->
            let open Flow_ast_mapper in
            let _ = visitor#type_annotation_hint bound in
            let _ = visitor#variance_opt variance in
            let _ = map_opt visitor#type_ default in
            ())
          (depends_of_tparams_map tparams_map EnvMap.empty)
      in
      let depends_of_interface { Ast.Statement.Interface.tparams; extends; body; _ } =
        depends_of_node
          (fun visitor ->
            let open Flow_ast_mapper in
            let _ = map_opt visitor#type_params tparams in
            let _ = map_list (map_loc visitor#generic_type) extends in
            let _ = map_loc visitor#object_type body in
            ())
          EnvMap.empty
      in
      let depends_of_root state = function
        | Annotation { annot; tparams_map; default_expression; _ } ->
          let state =
            Base.Option.value_map default_expression ~default:state ~f:(fun e ->
                depends_of_expression e state
            )
          in
          depends_of_annotation tparams_map annot state
        | Value { hint; expr } ->
          let state = depends_of_hint state hint in
          depends_of_expression expr state
        | ObjectValue
            {
              obj = { Ast.Expression.Object.properties; _ };
              synthesizable = ObjectSynthesizable _;
              _;
            } ->
          let open Ast.Expression.Object in
          let open Ast.Expression.Object.Property in
          Base.List.fold properties ~init:state ~f:(fun state -> function
            | Property
                ( _,
                  ( Method { value = (_, fn); _ }
                  | Init
                      {
                        value = (_, (Ast.Expression.Function fn | Ast.Expression.ArrowFunction fn));
                        _;
                      } )
                ) ->
              depends_of_fun true ALocMap.empty Hint_api.Hint_None ~statics:SMap.empty fn state
            | _ -> failwith "Object not synthesizable"
          )
        | ObjectValue { obj; obj_loc; _ } ->
          depends_of_expression (obj_loc, Ast.Expression.Object obj) EnvMap.empty
        | FunctionValue { hint; function_loc = _; function_; statics; arrow = _; tparams_map } ->
          depends_of_fun false tparams_map hint ~statics function_ state
        | EmptyArray { array_providers; _ } ->
          ALocSet.fold
            (fun loc acc ->
              EnvMap.update
                (Env_api.ArrayProviderLoc, loc)
                (function
                  | None -> Some (Nel.one id_loc)
                  | Some locs -> Some (Nel.cons id_loc locs))
                acc)
            array_providers
            state
        | For (_, exp) -> depends_of_expression exp state
        | Contextual { reason = _; hint; optional = _; default_expression } ->
          let state =
            Base.Option.value_map default_expression ~default:state ~f:(fun e ->
                depends_of_expression e state
            )
          in
          depends_of_hint state hint
        | Catch -> state
      in
      let depends_of_selector state = function
        | Computed exp -> depends_of_expression exp state
        | Prop { prop_loc; _ } ->
          (* In `const {d: {a, b}} = obj`, each prop might be reading from a refined value, \
             which is a write. We need to track these dependencies as well. *)
          let visitor = new use_visitor cx this_super_dep_loc_map env state in
          let writes = visitor#find_writes ~for_type:false ~allow_missing:true prop_loc in
          Base.List.iter ~f:(visitor#add ~why:prop_loc) writes;
          visitor#acc
        | Default
        | Elem _
        | ObjRest _
        | ArrRest _ ->
          state
      in
      let rec depends_of_default state = function
        | DefaultExpr e -> depends_of_expression e state
        | DefaultCons (e, d) ->
          let state = depends_of_expression e state in
          depends_of_default state d
        | DefaultSelector (d, s) ->
          let state = depends_of_default state d in
          depends_of_selector state s
      in
      let depends_of_lhs id_loc lhs_member_expression =
        (* When looking at a binding def, like `x = y`, in order to resolve this def we need
             to have resolved the providers for `x`, as well as the type of `y`, in order to check
             the type of `y` against `x`. So in addition to exploring the RHS, we also add the providers
             for `x` to the set of dependencies. *)
        match lhs_member_expression with
        | None ->
          let { Provider_api.providers = provider_entries; _ } =
            Base.Option.value_exn (Provider_api.providers_of_def providers id_loc)
          in
          if not @@ Provider_api.is_provider providers id_loc then
            Base.List.fold
              ~init:EnvMap.empty
              ~f:(fun acc { Provider_api.reason = r; _ } ->
                let key = (Env_api.OrdinaryNameLoc, Reason.poly_loc_of_reason r) in
                if Env_api.has_assigning_write key env_entries then
                  EnvMap.update
                    key
                    (function
                      | None -> Some (Nel.one id_loc)
                      | Some locs -> Some (Nel.cons id_loc locs))
                    acc
                else
                  acc)
              provider_entries
          else
            EnvMap.empty
        | Some e -> depends_of_expression ~for_expression_writes:true e EnvMap.empty
      in
      let depends_of_binding bind =
        let state = depends_of_lhs id_loc None in
        let rec rhs_loop bind state =
          match bind with
          | Root root -> depends_of_root state root
          | Select { selector; default; binding } ->
            let state = depends_of_selector state selector in
            let state =
              Base.Option.value_map default ~default:state ~f:(depends_of_default state)
            in
            rhs_loop binding state
        in
        rhs_loop bind state
      in
      let depends_of_update lhs =
        let state = depends_of_lhs id_loc lhs in
        match lhs with
        | Some _ -> (* assigning to member *) state
        | None ->
          (* assigning to identifier *)
          let visitor = new use_visitor cx this_super_dep_loc_map env state in
          let writes = visitor#find_writes ~for_type:false id_loc in
          Base.List.iter ~f:(visitor#add ~why:id_loc) writes;
          visitor#acc
      in
      let depends_of_op_assign lhs rhs =
        let lhs =
          match lhs with
          | (_, Ast.Pattern.Expression e) -> Some e
          | _ -> None
        in
        (* reusing depends_of_update, since the LHS of an op-assign is handled identically to an update *)
        let state = depends_of_update lhs in
        depends_of_expression rhs state
      in
      let depends_of_member_assign member_loc member rhs =
        let state =
          depends_of_node (fun visitor -> ignore @@ visitor#member member_loc member) EnvMap.empty
        in
        depends_of_expression rhs state
      in
      function
      | Binding binding -> depends_of_binding binding
      | ChainExpression (_, exp)
      | WriteExpression (_, exp) ->
        depends_of_expression ~for_expression_writes:true exp EnvMap.empty
      | Update _ -> depends_of_update None
      | MemberAssign { member_loc; member; rhs; _ } ->
        depends_of_member_assign member_loc member rhs
      | OpAssign { lhs; rhs; _ } -> depends_of_op_assign lhs rhs
      | Function
          {
            synthesizable_from_annotation;
            function_;
            has_this_def = _;
            function_loc = _;
            tparams_map;
            statics;
            hint;
          } ->
        depends_of_fun
          (synthesizable_from_annotation = FunctionSynthesizable)
          tparams_map
          hint
          ~statics
          function_
          EnvMap.empty
      | Class { class_; class_loc = _; class_implicit_this_tparam = _; this_super_write_locs = _ }
        ->
        depends_of_class class_
      | DeclaredClass (_, decl) -> depends_of_declared_class decl
      | TypeAlias (_, alias) -> depends_of_alias alias
      | OpaqueType (_, alias) -> depends_of_opaque alias
      | TypeParam (tparams_map, tparam) -> depends_of_tparam tparams_map tparam
      | Interface (_, inter) -> depends_of_interface inter
      | GeneratorNext (Some { return_annot; tparams_map; _ }) ->
        depends_of_annotation tparams_map return_annot EnvMap.empty
      | DeclaredModule (_, module_) -> depends_of_declared_module module_
      | GeneratorNext None -> EnvMap.empty
      | Enum _ ->
        (* Enums don't contain any code or type references, they're literal-like *) EnvMap.empty
      | Import _ -> (* same with all imports *) EnvMap.empty
      | NonBindingParam -> EnvMap.empty

    (* Is the variable defined by this def able to be recursively depended on, e.g. created as a 0->1 tvar before being
       resolved? *)
    let recursively_resolvable =
      let rec bind_loop b =
        match b with
        | Root Catch -> true
        | Root (Annotation { default_expression = None; _ }) -> true
        | Root (Annotation { default_expression = Some _; _ }) -> false
        | Root (ObjectValue { synthesizable = ObjectSynthesizable _; _ }) -> true
        | Root (For _ | Value _ | FunctionValue _ | Contextual _ | EmptyArray _ | ObjectValue _) ->
          false
        | Select { selector = Computed _ | Default; _ } -> false
        | Select { binding; _ } -> bind_loop binding
      in
      function
      | Binding bind -> bind_loop bind
      | GeneratorNext _
      | TypeAlias _
      | OpaqueType _
      | TypeParam _
      | Function { synthesizable_from_annotation = FunctionSynthesizable; _ }
      | Interface _
      (* Imports are academic here since they can't be in a cycle anyways, since they depend on nothing *)
      | Import { import_kind = Ast.Statement.ImportDeclaration.(ImportType | ImportTypeof); _ }
      | Import
          {
            import =
              Named { kind = Some Ast.Statement.ImportDeclaration.(ImportType | ImportTypeof); _ };
            _;
          }
      | Class _
      | NonBindingParam
      | DeclaredClass _
      | DeclaredModule _ ->
        true
      | ChainExpression _
      | WriteExpression _
      | Update _
      | MemberAssign _
      | OpAssign _
      | Function _
      | Enum _
      | Import _ ->
        false
  end

  let annotation_locs scopes loc =
    let rec bind_loop b =
      match b with
      | Root Catch
      | Root (Annotation _)
      | Root (ObjectValue { synthesizable = ObjectSynthesizable _; _ }) ->
        []
      | Root (ObjectValue { synthesizable = MissingMemberReturns locs; _ }) -> Nel.to_list locs
      | Root (For _ | Value _ | FunctionValue _ | Contextual _ | EmptyArray _ | ObjectValue _) ->
        begin
          try
            let { Scope_api.With_ALoc.Def.locs = (loc, _); _ } =
              Scope_api.With_ALoc.def_of_use scopes loc
            in
            [loc]
          with
          | Scope_api.With_ALoc.Missing_def _ -> []
        end
      | Select { selector = Computed _ | Default; _ } -> []
      | Select { binding; _ } -> bind_loop binding
    in
    function
    | Binding bind -> bind_loop bind
    | GeneratorNext None -> [loc]
    | Function { synthesizable_from_annotation = MissingReturn loc; _ } -> [loc]
    | TypeAlias _
    | OpaqueType _
    | TypeParam _
    | Function _
    | Interface _
    | Enum _
    | Import _
    | Class _
    | DeclaredClass _
    | ChainExpression _
    | WriteExpression _
    | DeclaredModule _
    | NonBindingParam
    | GeneratorNext (Some _) ->
      []
    (* TODO *)
    | Update _
    | MemberAssign _
    | OpAssign _ ->
      []

  let dependencies cx this_super_dep_loc_map env (kind, loc) (def, _, _, _) acc =
    let depends = FindDependencies.depends cx this_super_dep_loc_map env loc def in
    EnvMap.update
      (kind, loc)
      (function
        | None -> Some depends
        | Some _ ->
          failwith
            (Utils_js.spf
               "Duplicate name defs for the same location %s"
               (ALoc.debug_to_string ~include_source:true loc)
            ))
      acc

  let build_graph cx env map =
    (* This is a forwarding map from the def loc of this and super to the def loc of the functions
       and classes that define this and super. We need this forwarding mechanism, because this and
       super are not write entries that will be resolved by env_resolution. Instead, they are
       indirectly resolved when resolving their defining functions and classes. Therefore, when
       we see a read of `this`/`super`, instead of saying it depends on the write of `this`/`super`,
       we use this forwarding map to say it actually depends on the functions/classes that define
       `this`/`super`. *)
    let this_super_dep_loc_map =
      EnvMap.fold
        (fun kind_and_loc def acc ->
          match def with
          | (Class { this_super_write_locs = locs; _ }, _, _, _)
          | ( Binding
                (Root
                  (ObjectValue { synthesizable = ObjectSynthesizable { this_write_locs = locs }; _ })
                  ),
              _,
              _,
              _
            ) ->
            acc
            |> EnvSet.fold
                 (fun this_super_kind_and_loc acc ->
                   EnvMap.add this_super_kind_and_loc (Some kind_and_loc) acc)
                 locs
          | ( Function
                {
                  function_loc;
                  function_ =
                    { Ast.Function.params = (_, { Ast.Function.Params.this_ = None; _ }); _ };
                  _;
                },
              _,
              _,
              _
            )
          | ( Binding
                (Root
                  (FunctionValue
                    {
                      function_loc;
                      function_ =
                        { Ast.Function.params = (_, { Ast.Function.Params.this_ = None; _ }); _ };
                      arrow = false;
                      _;
                    }
                    )
                  ),
              _,
              _,
              _
            ) ->
            EnvMap.add (Env_api.FunctionThisLoc, function_loc) None acc
          | _ -> acc)
        map
        EnvMap.empty
    in
    EnvMap.fold (dependencies cx this_super_dep_loc_map env) map EnvMap.empty

  let build_ordering cx ({ Env_api.scopes; _ } as env) map =
    let graph = build_graph cx env map in
    let order_graph = EnvMap.map (fun deps -> EnvMap.keys deps |> EnvSet.of_list) graph in
    let roots = EnvMap.keys order_graph |> EnvSet.of_list in
    let sort =
      try Tarjan.topsort ~roots order_graph |> List.rev with
      | Not_found ->
        let all_locs =
          EnvMap.values order_graph
          |> List.map EnvSet.elements
          |> List.flatten
          |> EnvSet.of_list
          |> EnvSet.elements
        in
        let all =
          all_locs
          |> Base.List.map ~f:(fun (_, l) -> ALoc.debug_to_string ~include_source:false l)
          |> String.concat ","
        in
        let missing_roots =
          all_locs
          |> Base.List.filter ~f:(fun l -> not @@ EnvSet.mem l roots)
          |> Base.List.map ~f:(fun (_, l) -> ALoc.debug_to_string ~include_source:false l)
          |> String.concat ","
        in
        let roots =
          EnvSet.elements roots
          |> Base.List.map ~f:(fun (_, l) -> ALoc.debug_to_string ~include_source:true l)
          |> String.concat ","
        in
        failwith (Printf.sprintf "roots: %s\n\nall: %s\nmissing_roots: %s." roots all missing_roots)
    in
    let result_of_scc (fst, rest) =
      let element_of_loc (kind, loc) =
        let (def, _, _, reason) = EnvMap.find (kind, loc) map in
        if EnvSet.mem (kind, loc) (EnvMap.find (kind, loc) order_graph) then
          if FindDependencies.recursively_resolvable def then
            Resolvable (kind, loc)
          else
            let depends = EnvMap.find (kind, loc) graph in
            let recursion = EnvMap.find (kind, loc) depends in
            Illegal
              {
                payload = (kind, loc);
                reason;
                recursion;
                annot_locs = annotation_locs scopes loc def;
              }
        else
          Normal (kind, loc)
      in
      match rest with
      | [] -> Singleton (element_of_loc fst)
      | _ ->
        let component = (fst, rest) in
        if
          Base.List.for_all
            ~f:(fun m ->
              let (def, _, _, _) = EnvMap.find m map in
              FindDependencies.recursively_resolvable def)
            (fst :: rest)
        then
          ResolvableSCC (Nel.map element_of_loc component)
        else
          let elements =
            Nel.map
              (fun (kind, loc) ->
                let (def, _, _, reason) = EnvMap.find (kind, loc) map in
                let depends = EnvMap.find (kind, loc) graph in
                let edges =
                  EnvMap.fold
                    (fun k v acc ->
                      if
                        k != (kind, loc)
                        && Nel.mem
                             ~equal:(fun k1 k2 -> Env_api.EnvKey.compare k1 k2 = 0)
                             k
                             component
                      then
                        Nel.to_list v @ acc
                      else
                        acc)
                    depends
                    []
                  |> Nel.of_list_exn
                in
                {
                  payload = element_of_loc (kind, loc);
                  reason;
                  recursion = edges;
                  annot_locs = annotation_locs scopes loc def;
                })
              component
          in
          IllegalSCC elements
    in
    Base.List.map ~f:result_of_scc sort
end

module DummyFlow (Context : C) = struct
  type cx = Context.t

  let add_output _ ?trace _ = ignore trace
end

module Make_Test_With_Cx (Context : C) = Make (Context) (DummyFlow (Context))
