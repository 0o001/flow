Error --------------------------------------------------------------------------------------------------- import.js:16:4

Cannot cast `mapped` to object type because string [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:16:4
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:30
    1| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:16:30
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:16:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:16:4
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:30
    1| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:16:30
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:16:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:16:4
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:3:42
    3| export type MappedO = {[key in keyof O]: O[key]};
                                                ^^^^^^ [1]
   import.js:16:30
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:16:4

Cannot cast `mapped` to object type because boolean [1] is incompatible with empty [2] in property `baz`.
[incompatible-cast]

   import.js:16:4
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:44
    1| type O = {foo: number, bar?: string, +baz: bool};
                                                  ^^^^ [1]
   import.js:16:43
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                                 ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:16:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   import.js:16:4
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:16
    1| type O = {foo: number, bar?: string, +baz: bool};
                      ^^^^^^ [1]
   import.js:16:18
   16|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                        ^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- import.js:17:10

Cannot assign `true` to `mapped.baz` because property `baz` is not writable. [cannot-write]

   17|   mapped.baz = true; // ERROR
                ^^^


Error -------------------------------------------------------------------------------------------------- import.js:25:15

Cannot assign `true` to `addOptional.baz` because property `baz` is not writable. [cannot-write]

   25|   addOptional.baz = true; // ERROR
                     ^^^


Error -------------------------------------------------------------------------------------------------- import.js:32:12

Cannot assign `4` to `readonly.foo` because property `foo` is not writable. [cannot-write]

   32|   readonly.foo = 4; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:33:12

Cannot assign `'str'` to `readonly.bar` because property `bar` is not writable. [cannot-write]

   33|   readonly.bar = 'str'; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:34:12

Cannot assign `false` to `readonly.baz` because property `baz` is not writable. [cannot-write]

   34|   readonly.baz = false; // ERROR;
                  ^^^


Error --------------------------------------------------------------------------------------------------- import.js:45:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:45:4
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:7:60
    7| export type ParameterizedId<O: {...}> = {[key in keyof O]: O[key]};
                                                                  ^^^^^^ [1]
   import.js:45:30
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:45:4

Cannot cast `mapped` to object type because string [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:45:4
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:38:30
   38| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:45:30
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:45:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:45:4
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:38:30
   38| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:45:30
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:45:4

Cannot cast `mapped` to object type because boolean [1] is incompatible with empty [2] in property `baz`.
[incompatible-cast]

   import.js:45:4
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:38:44
   38| type O = {foo: number, bar?: string, +baz: bool};
                                                  ^^^^ [1]
   import.js:45:43
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                                 ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:45:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   import.js:45:4
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:38:16
   38| type O = {foo: number, bar?: string, +baz: bool};
                      ^^^^^^ [1]
   import.js:45:18
   45|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                        ^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- import.js:46:10

Cannot assign `true` to `mapped.baz` because property `baz` is not writable. [cannot-write]

   46|   mapped.baz = true; // ERROR
                ^^^


Error -------------------------------------------------------------------------------------------------- import.js:54:15

Cannot assign `true` to `addOptional.baz` because property `baz` is not writable. [cannot-write]

   54|   addOptional.baz = true; // ERROR
                     ^^^


Error -------------------------------------------------------------------------------------------------- import.js:61:12

Cannot assign `4` to `readonly.foo` because property `foo` is not writable. [cannot-write]

   61|   readonly.foo = 4; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:62:12

Cannot assign `'str'` to `readonly.bar` because property `bar` is not writable. [cannot-write]

   62|   readonly.bar = 'str'; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:63:12

Cannot assign `false` to `readonly.baz` because property `baz` is not writable. [cannot-write]

   63|   readonly.baz = false; // ERROR;
                  ^^^


Error ------------------------------------------------------------------------------------ no_explicit_exactness.js:7:20

Mapped Types take on the exactness of the argument passed to keyof. They do not support explicit exact or inexact
syntax. [invalid-mapped-type]

                         v----------
   7| type MappedExact = {| // ERROR
   8|   [key in keyof O]: number
   9| |}
      -^


Error ----------------------------------------------------------------------------------- no_explicit_exactness.js:11:22

Mapped Types take on the exactness of the argument passed to keyof. They do not support explicit exact or inexact
syntax. [invalid-mapped-type]

                            v---------
   11| type MappedInexact = { // ERROR
   12|   [key in keyof O]: number,
   13|   ...
   14| }
       ^


Error ------------------------------------------------------------------------------------------- no_other_props.js:3:20

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                         v
   3| type MappedFirst = {
   4|   [key in keyof {foo: number}]: number, // ERROR
   5|   prop: number,
   6| };
      ^


Error ------------------------------------------------------------------------------------------- no_other_props.js:7:19

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                         v
    7| type SliceFirst = {
    8|   prop: number,
    9|   [key in keyof {foo: number}]: number, // ERROR
   10| };
       ^


Error ------------------------------------------------------------------------------------------ no_other_props.js:11:20

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                          v
   11| type SpreadFirst = {
   12|   ...{prop: number},
   13|   [key in keyof {foo: number}]: number, // ERROR
   14| };
       ^


Error ------------------------------------------------------------------------------------------ no_other_props.js:15:21

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                           v
   15| type MappedLater1 = {
   16|   ...{prop: number},
   17|   foo: number,
   18|   [key in keyof {foo: number}]: number, // ERROR
   19| };
       ^


Error ------------------------------------------------------------------------------------------ no_other_props.js:20:21

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                           v
   20| type MappedLater2 = {
   21|   foo: number,
   22|   ...{prop: number},
   23|   foo: number,
   24|   [key in keyof {foo: number}]: number, // ERROR
   25| };
       ^


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:11:4

Cannot cast `mapped` to empty because `Mapped` [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic.js:11:4
   11|   (mapped: empty); // ERROR!
          ^^^^^^

References:
   non_homomorphic.js:6:25
    6|   declare const mapped: Mapped;
                               ^^^^^^ [1]
   non_homomorphic.js:11:12
   11|   (mapped: empty); // ERROR!
                  ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:12:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   non_homomorphic.js:12:4
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
          ^^^^^^

References:
   non_homomorphic.js:4:33
    4|   type Mapped = {[key in Keys]: number};
                                       ^^^^^^ [1]
   non_homomorphic.js:12:30
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
                                    ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:12:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   non_homomorphic.js:12:4
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
          ^^^^^^

References:
   non_homomorphic.js:4:33
    4|   type Mapped = {[key in Keys]: number};
                                       ^^^^^^ [1]
   non_homomorphic.js:12:18
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
                        ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:21:4

Cannot cast `withLeftovers` to object type because number [1] is incompatible with string [2] in property `foo`.
[incompatible-cast]

   non_homomorphic.js:21:4
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
          ^^^^^^^^^^^^^

References:
   non_homomorphic.js:18:50
   18|   type WithLeftovers = {[key in 'foo' | number]: number};
                                                        ^^^^^^ [1]
   non_homomorphic.js:21:43
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
                                                 ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:21:4

Cannot cast `withLeftovers` to object type because number [1] is incompatible with string [2] in the indexer property.
[incompatible-cast]

   non_homomorphic.js:21:4
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
          ^^^^^^^^^^^^^

References:
   non_homomorphic.js:18:50
   18|   type WithLeftovers = {[key in 'foo' | number]: number};
                                                        ^^^^^^ [1]
   non_homomorphic.js:21:30
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
                                    ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:40:4

Cannot cast `keyMirroredObject` to object type because string literal `bar` [1] is incompatible with string literal
`baz` [2] in property `bar`. [incompatible-cast]

   non_homomorphic.js:40:4
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
          ^^^^^^^^^^^^^^^^^

References:
   non_homomorphic.js:35:69
   35|   declare function keyMirror<T>(...$ReadOnlyArray<T>): {[key in T]: key};
                                                                           ^^^ [1]
   non_homomorphic.js:40:41
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
                                               ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:40:4

Cannot cast `keyMirroredObject` to object type because string literal `baz` [1] is incompatible with string literal
`foo` [2] in property `baz`. [incompatible-cast]

   non_homomorphic.js:40:4
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
          ^^^^^^^^^^^^^^^^^

References:
   non_homomorphic.js:35:69
   35|   declare function keyMirror<T>(...$ReadOnlyArray<T>): {[key in T]: key};
                                                                           ^^^ [1]
   non_homomorphic.js:40:53
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
                                                           ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:40:4

Cannot cast `keyMirroredObject` to object type because string literal `foo` [1] is incompatible with string literal
`bar` [2] in property `foo`. [incompatible-cast]

   non_homomorphic.js:40:4
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
          ^^^^^^^^^^^^^^^^^

References:
   non_homomorphic.js:35:69
   35|   declare function keyMirror<T>(...$ReadOnlyArray<T>): {[key in T]: key};
                                                                           ^^^ [1]
   non_homomorphic.js:40:29
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
                                   ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:48:4

Cannot cast `noContext` to object type because property `baz` is missing in object type [1] but exists in object
type [2]. [prop-missing]

   non_homomorphic.js:48:4
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
          ^^^^^^^^^

References:
   non_homomorphic.js:45:96
   45|   declare function ObjWithKeys<T>(x: {[key in T]: number}, ...$ReadOnlyArray<T>): {[key in T]: number};
                                                                                                      ^^^^^^ [1]
   non_homomorphic.js:48:15
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:48:4

Cannot cast `noContext` to object type because number [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   non_homomorphic.js:48:4
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
          ^^^^^^^^^

References:
   non_homomorphic.js:45:96
   45|   declare function ObjWithKeys<T>(x: {[key in T]: number}, ...$ReadOnlyArray<T>): {[key in T]: number};
                                                                                                      ^^^^^^ [1]
   non_homomorphic.js:48:33
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
                                       ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:48:4

Cannot cast `noContext` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   non_homomorphic.js:48:4
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
          ^^^^^^^^^

References:
   non_homomorphic.js:45:96
   45|   declare function ObjWithKeys<T>(x: {[key in T]: number}, ...$ReadOnlyArray<T>): {[key in T]: number};
                                                                                                      ^^^^^^ [1]
   non_homomorphic.js:48:21
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
                           ^^^^^ [2]


Error ------------------------------------------------------------------------------- non_homomorphic_resolution.js:10:4

Cannot cast `mappedTypeApp` to empty because `Mapped` [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic_resolution.js:10:4
   10|   (mappedTypeApp: empty); // ERROR
          ^^^^^^^^^^^^^

References:
   non_homomorphic_resolution.js:9:32
    9|   declare const mappedTypeApp: MappedTypeApp;
                                      ^^^^^^^^^^^^^ [1]
   non_homomorphic_resolution.js:10:19
   10|   (mappedTypeApp: empty); // ERROR
                         ^^^^^ [2]


Error ------------------------------------------------------------------------------- non_homomorphic_resolution.js:18:4

Cannot cast `mappedKeys` to empty because object type [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic_resolution.js:18:4
   18|   (mappedKeys: empty); // ERROR
          ^^^^^^^^^^

References:
   non_homomorphic_resolution.js:17:29
   17|   declare const mappedKeys: MappedKeys;
                                   ^^^^^^^^^^ [1]
   non_homomorphic_resolution.js:18:16
   18|   (mappedKeys: empty); // ERROR
                      ^^^^^ [2]


Error ------------------------------------------------------------------------------- non_homomorphic_resolution.js:19:4

Cannot cast `mappedKeys` to object type because indexed object type [1] is incompatible with exact object type [2].
[incompatible-indexer]

   non_homomorphic_resolution.js:19:4
   19|   (mappedKeys: {foo: number}); // TODO: OK, error for now
          ^^^^^^^^^^

References:
   non_homomorphic_resolution.js:17:29
   17|   declare const mappedKeys: MappedKeys;
                                   ^^^^^^^^^^ [1]
   non_homomorphic_resolution.js:19:16
   19|   (mappedKeys: {foo: number}); // TODO: OK, error for now
                      ^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------- non_homomorphic_resolution.js:27:4

Cannot cast `mappedEval` to empty because `Mapped` [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic_resolution.js:27:4
   27|   (mappedEval: empty); // ERROR
          ^^^^^^^^^^

References:
   non_homomorphic_resolution.js:26:29
   26|   declare const mappedEval: MappedEval;
                                   ^^^^^^^^^^ [1]
   non_homomorphic_resolution.js:27:16
   27|   (mappedEval: empty); // ERROR
                      ^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- optionality.js:9:4

Cannot cast `preserve` to object type because string [1] is incompatible with number [2] in property `bar`.
[incompatible-cast]

   optionality.js:9:4
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
         ^^^^^^^^

References:
   optionality.js:5:38
   5|   type Preserve = {[key in keyof O]: O[key]};
                                           ^^^^^^ [1]
   optionality.js:9:34
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
                                       ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- optionality.js:9:4

Cannot cast `preserve` to object type because number [1] is incompatible with string [2] in property `bar`. This
property is invariantly typed. See
https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number. [incompatible-cast]

   optionality.js:9:4
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
         ^^^^^^^^

References:
   optionality.js:9:34
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
                                       ^^^^^^ [1]
   optionality.js:1:30
   1| type O = {foo: number, bar?: string};
                                   ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- optionality.js:9:4

Cannot cast `preserve` to object type because number [1] is incompatible with string [2] in property `foo`.
[incompatible-cast]

   optionality.js:9:4
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
         ^^^^^^^^

References:
   optionality.js:5:38
   5|   type Preserve = {[key in keyof O]: O[key]};
                                           ^^^^^^ [1]
   optionality.js:9:20
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
                         ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- optionality.js:13:10

Cannot cast object literal to `Preserve` because string [1] is incompatible with number [2] in property `foo`.
[incompatible-cast]

   optionality.js:13:10
   13|   ({foo: 'str', bar: 3}: Preserve); // ERROR
                ^^^^^ [1]

References:
   optionality.js:5:38
    5|   type Preserve = {[key in keyof O]: O[key]};
                                            ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- optionality.js:13:22

Cannot cast object literal to `Preserve` because number [1] is incompatible with string [2] in property `bar`.
[incompatible-cast]

   optionality.js:13:22
   13|   ({foo: 'str', bar: 3}: Preserve); // ERROR
                            ^ [1]

References:
   optionality.js:1:30
    1| type O = {foo: number, bar?: string};
                                    ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- optionality.js:28:19

Mapped Types do not yet support optionality removal. [invalid-mapped-type]

   28|   type Removed = {[key in keyof O]-?: O[key]}; // ERROR
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^


Error -------------------------------------------------------------------------------------------- pick_and_omit.js:15:9

Cannot assign `3` to `noFoo.foo` because property `foo` is missing in `Omit` [1]. [prop-missing]

   pick_and_omit.js:15:9
   15|   noFoo.foo = 3; // ERROR!
               ^^^

References:
   pick_and_omit.js:14:24
   14|   declare const noFoo: Omit<O, 'foo'>;
                              ^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:21:36

Cannot instantiate `Omit` because an index signature declaring the expected key / value type is missing in `O` [1] in
type argument `Keys`. [prop-missing]

   pick_and_omit.js:21:36
   21|   declare const noKeysBad: Omit<O, string>; // ERROR! string is not a subtype of $Keys<O>
                                          ^^^^^^

References:
   pick_and_omit.js:21:33
   21|   declare const noKeysBad: Omit<O, string>; // ERROR! string is not a subtype of $Keys<O>
                                       ^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:37:47

Cannot call `omitInput` with object literal bound to `x` because property `bar` is missing in object literal [1] but
exists in `Omit` [2]. [prop-missing]

   pick_and_omit.js:37:47
   37|   const badCall = omitInput({foo: 3, bar: 3}, {foo: 3}, ('foo': 'foo')); // ERROR 2x
                                                     ^^^^^^^^ [1]

References:
   pick_and_omit.js:35:65
   35|   declare function omitInput<O: {...}, Keys: $Keys<O>>(o: O, x: Omit<O, Keys>, ...$ReadOnlyArray<Keys>): void;
                                                                       ^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:37:47

Cannot call `omitInput` with object literal bound to `x` because property `foo` is missing in `Omit` [1] but exists in
object literal [2]. [prop-missing]

   pick_and_omit.js:37:47
   37|   const badCall = omitInput({foo: 3, bar: 3}, {foo: 3}, ('foo': 'foo')); // ERROR 2x
                                                     ^^^^^^^^ [2]

References:
   pick_and_omit.js:35:65
   35|   declare function omitInput<O: {...}, Keys: $Keys<O>>(o: O, x: Omit<O, Keys>, ...$ReadOnlyArray<Keys>): void;
                                                                       ^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:51:11

Cannot get `onlyFoo.bar` because property `bar` is missing in `Pick` [1]. [prop-missing]

   pick_and_omit.js:51:11
   51|   onlyFoo.bar; // ERROR!
                 ^^^

References:
   pick_and_omit.js:50:26
   50|   declare const onlyFoo: Pick<P, 'foo'>;
                                ^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:64:47

Cannot call `pickInput` with object literal bound to `x` because property `bar` is missing in `Pick` [1] but exists in
object literal [2]. [prop-missing]

   pick_and_omit.js:64:47
   64|   const badCall = pickInput({foo: 3, bar: 3}, {bar : 3}, 'foo'); // ERROR 2x
                                                     ^^^^^^^^^ [2]

References:
   pick_and_omit.js:61:65
   61|   declare function pickInput<O: {...}, Keys: $Keys<O>>(o: O, x: Pick<O, Keys>, ...$ReadOnlyArray<Keys>): void;
                                                                       ^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:64:47

Cannot call `pickInput` with object literal bound to `x` because property `foo` is missing in object literal [1] but
exists in `Pick` [2]. [prop-missing]

   pick_and_omit.js:64:47
   64|   const badCall = pickInput({foo: 3, bar: 3}, {bar : 3}, 'foo'); // ERROR 2x
                                                     ^^^^^^^^^ [1]

References:
   pick_and_omit.js:61:65
   61|   declare function pickInput<O: {...}, Keys: $Keys<O>>(o: O, x: Pick<O, Keys>, ...$ReadOnlyArray<Keys>): void;
                                                                       ^^^^^^^^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- reasons.js:9:34

string literal `bar` [1] is incompatible with string literal `foo` [2] in type argument `T`. [incompatible-type-arg]

   reasons.js:9:34
   9|   type FooBarObj = {foo: number, bar: number};
                                       ^^^ [1]

References:
   reasons.js:7:20
   7|   type TakesFoo<T: 'foo'> = T;
                         ^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:26:4

Cannot cast `badKey` to `Mapped` because property `bar` is missing in `Mapped` [1] but exists in object type [2].
[prop-missing]

   test.js:26:4
   26|   (badKey: Mapped<O>); // ERROR
          ^^^^^^

References:
   test.js:26:12
   26|   (badKey: Mapped<O>); // ERROR
                  ^^^^^^^^^ [1]
   test.js:25:25
   25|   declare const badKey: {bar: {contents: number}};
                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:26:4

Cannot cast `badKey` to `Mapped` because property `foo` is missing in object type [1] but exists in `Mapped` [2].
[prop-missing]

   test.js:26:4
   26|   (badKey: Mapped<O>); // ERROR
          ^^^^^^

References:
   test.js:25:25
   25|   declare const badKey: {bar: {contents: number}};
                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   test.js:26:12
   26|   (badKey: Mapped<O>); // ERROR
                  ^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:29:4

Cannot cast `badVal` to `Mapped` because string [1] is incompatible with number [2] in property `foo.contents`.
[incompatible-cast]

   test.js:29:4
   29|   (badVal: Mapped<O>); // ERROR
          ^^^^^^

References:
   test.js:28:42
   28|   declare const badVal: {foo: {contents: string}};
                                                ^^^^^^ [1]
   test.js:1:18
    1| type O = {| foo: number |}
                        ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:35:5

Mapped Types are not supported in interfaces or declared classes. [invalid-mapped-type]

   35|     [x in keyof O]: number; // ERROR
           ^^^^^^^^^^^^^^^^^^^^^^


Error ----------------------------------------------------------------------------------------------------- test.js:38:5

Mapped Types are not supported in interfaces or declared classes. [invalid-mapped-type]

   38|     [x in keyof O]: number; // ERROR
           ^^^^^^^^^^^^^^^^^^^^^^


Error ----------------------------------------------------------------------------------------------------- test.js:47:4

Cannot cast `mappedIndexer.foo` to number because `Box` [1] is incompatible with number [2]. [incompatible-cast]

   test.js:47:4
   47|   (mappedIndexer.foo: number); // ERROR
          ^^^^^^^^^^^^^^^^^

References:
   test.js:11:21
   11|   [key in keyof O]: Box<O[key]>,
                           ^^^^^^^^^^^ [1]
   test.js:47:23
   47|   (mappedIndexer.foo: number); // ERROR
                             ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:48:4

Cannot cast `mappedIndexer.bar` to string because `Box` [1] is incompatible with string [2]. [incompatible-cast]

   test.js:48:4
   48|   (mappedIndexer.bar: string); // ERROR
          ^^^^^^^^^^^^^^^^^

References:
   test.js:11:21
   11|   [key in keyof O]: Box<O[key]>,
                           ^^^^^^^^^^^ [1]
   test.js:48:23
   48|   (mappedIndexer.bar: string); // ERROR
                             ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- test.js:60:12

Cannot assign `3` to `readonly.foo` because property `foo` is not writable. [cannot-write]

   60|   readonly.foo = 3; // ERROR
                  ^^^


Error ---------------------------------------------------------------------------------------------------- test.js:64:14

Cannot get `writeonly.foo` because property `foo` is not readable. [cannot-read]

   64|   (writeonly.foo: number); // ERROR
                    ^^^


Error ---------------------------------------------------------------------------------------------------- test.js:70:19

Cannot assign `'str'` to `readonlyIndexer.qux` because property `qux` is not writable. [cannot-write]

   70|   readonlyIndexer.qux = 'str'; // ERROR
                         ^^^


Error ----------------------------------------------------------------------------------------------------- test.js:77:4

Cannot cast `partial.foo` to number because undefined [1] is incompatible with number [2]. [incompatible-cast]

   test.js:77:4
   77|   (partial.foo: number); // ERROR
          ^^^^^^^^^^^

References:
   test.js:75:48
   75|   type Partial<T: {...}> = {[key in keyof T]?: T[key]};
                                                      ^^^^^^ [1]
   test.js:77:17
   77|   (partial.foo: number); // ERROR
                       ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:81:4

Cannot cast `partialIndexer.qux` to string because undefined [1] is incompatible with string [2]. [incompatible-cast]

   test.js:81:4
   81|   (partialIndexer.qux: string); // ERROR
          ^^^^^^^^^^^^^^^^^^

References:
   test.js:75:48
   75|   type Partial<T: {...}> = {[key in keyof T]?: T[key]};
                                                      ^^^^^^ [1]
   test.js:81:24
   81|   (partialIndexer.qux: string); // ERROR
                              ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- test.js:92:28

Cannot instantiate `MappedConstrained` because number [1] is incompatible with string [2] in type argument `T`.
[incompatible-type-arg]

   test.js:92:28
   92|   declare var constrained: MappedConstrained<O>; // ERROR HERE, NOT IN DEFINITION OF MAPPEDCONSTRAINED
                                  ^^^^^^^^^^^^^^^^^^^^

References:
   test.js:1:18
    1| type O = {| foo: number |}
                        ^^^^^^ [1]
   test.js:87:26
   87|   type ConstrainedBox<T: string> = Box<T>;
                                ^^^^^^ [2]



Found 69 errors
